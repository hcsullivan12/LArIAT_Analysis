////////////////////////////////////////////////////////////////////////
// Class:       PionXSUsingTruth
// Module Type: analyzer
// File:        PionXSUsingTruth_module.cc
//
// Generated at Wed May 22 11:52:52 2019 by Hunter Sullivan using artmod
// from cetpkgsupport v1_10_02.
//
// The module calculates all cross sections for all pion processes
// using the thin slab method. This is supplemented with an algorithm
// to sub classify inelastic processes. 
//
////////////////////////////////////////////////////////////////////////

// framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

// LArSoft includes
#include "larsim/MCCheater/BackTrackerService.h"
#include "larsim/MCCheater/ParticleInventoryService.h"

// lariatsoft includes
#include "LArIATAnaModules/InelasticSubClassifier.h"

class PionXSUsingTruth;

class PionXSUsingTruth : public art::EDAnalyzer {
public:
  explicit PionXSUsingTruth(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  PionXSUsingTruth(PionXSUsingTruth const &) = delete;
  PionXSUsingTruth(PionXSUsingTruth &&) = delete;
  PionXSUsingTruth & operator = (PionXSUsingTruth const &) = delete;
  PionXSUsingTruth & operator = (PionXSUsingTruth &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;
  void beginRun(art::Run const & r) override;
  void beginSubRun(art::SubRun const & sr) override;
  void endJob() override;
  void endRun(art::Run const & r) override;
  void endSubRun(art::SubRun const & sr) override;
  void reconfigure(fhicl::ParameterSet const & p) override;
  void respondToCloseInputFile(art::FileBlock const & fb) override;
  void respondToCloseOutputFiles(art::FileBlock const & fb) override;
  void respondToOpenInputFile(art::FileBlock const & fb) override;
  void respondToOpenOutputFiles(art::FileBlock const & fb) override;

private:

  // Declare member data here.
  bool fVerbose = false;

};


PionXSUsingTruth::PionXSUsingTruth(fhicl::ParameterSet const & pset)
  : EDAnalyzer(pset)
{
  this->reconfigure(pset);
}

void PionXSUsingTruth::reconfigure(fhicl::ParameterSet const & p)
{}

void PionXSUsingTruth::analyze(art::Event const & evt)
{
  // ### Get useful services

  // ### Geometry
  art::ServiceHandle<geo::Geometry> geom;
  // ### Backtracker to recover truth information
  art::ServiceHandle<cheat::BackTrackerService> bt;
  art::ServiceHandle<cheat::ParticleInventoryService> pi_serv;
  const sim::ParticleList& plist = pi_serv->ParticleList();

  // ### Store the event, run, and subrun
  run    = evt.run();
  subrun = evt.subrun();
  event  = evt.event();

  // ### Loop over the g4 particles
  for (size_t p = 0; p < plist.size(); p++)
  {
    // ### Get the true particle and it's process, skip if not primary
    auto        mcParticle = plist.Particle();
    if ( !(mcParticle.Process().find("primary") != std::string::npos) ) continue;
 
    // ### Get simIDE associated to the primary
    auto primSimIDE = bt->TrackIdToSimIDEs_Ps(mcParticle->TrackId(), geom->View(0));

    // ### Order them in order of increasing Z
    std::map<double, sim::IDE> orderedSimIDE;
    for (auto ide : primSimIDE ) orderedSimIDE[ide->z] = *ide;

    // ### Storing the interaction type
    std::string interactionLabel("");
    double mass = mcParticle->Mass();

    // ### Storing the kinetic energy and momentum most upstream
    simb::MCTrajectory trueTrj = mcParticle->Trajectory();
    auto     firstInTPCpoint  = trueTrj.begin();
    TVector3 momentum0 = firstInTPCpoint->second.Vect();
    double   kinEn0    = 1000*TMath::Sqrt( momentum0.Mag()*momentum0.Mag() + mass ) - mass; // converted to MeV

    hInitialKE->Fill(kinEn0);
    hInitialPz->Fill(1000*momentum0.Z());

    // ### Identify the first traj point in TPC
    for (auto itTrj = trueTrj.begin(); itTrj != std::prev(trueTrj.end()); itTrj++)
    {
      auto pos = itTrj->first;
      if (TPC_BOUND_X[0] > pos.X() || pos.X() > TPC_BOUND_X[1] ||
          TPC_BOUND_Y[0] > pos.Y() || pos.Y() > TPC_BOUND_Y[1] || 
          pos.Z() < TPC_BOUND_Z[0]) continue;
      
      firstInTPCpoint = itTrj;
      break;
    }
    nEvtsPreTPC++;
    hXZPre->Fill((firstInTPCpoint->first).Z(), (firstInTPCpoint->first).X());
    hYZPre->Fill((firstInTPCpoint->first).Z(), (firstInTPCpoint->first).Y());

    // ### If we didn't enter TPC, we're done here
    if (firstInTPCPoint == trueTrj.begin()) continue;
    nEvtsPostTPC++;
    hXZ->Fill((firstInTPCpoint->first).Z(), (firstInTPCpoint->first).X());
    hYZ->Fill((firstInTPCpoint->first).Z(), (firstInTPCpoint->first).Y());

    // ### Algorithm to extract last interesting point,
    // ### and to identify the sub process type
    // ### Sub processes = (inelastic, ch-exch, absorp, pi-prod)
    InelasticSubClassifier subclassifier;
    auto interactionSubtype = subclassifier.Classify(plist);

    // ### Identify the last interesting point in TPC
    auto lastInTPCpoint = std::prev(trueTrj.end());
    // The last point is a bit more complicated:
    // if there's no interaction, then it is simply the last point in the TPC
    // if there's one or more interaction points, it's the first interaction point deemed interesting (no coulomb)
    // Take the interaction Map... check if there's something there
    auto trjProcessMap =  trueTrj.TrajectoryProcesses();
    if (trjProcessMap.size())
    {
      for (auto const& couple: trjProcessMap) 
      { 
        // I'm not interested in the CoulombScat, LArVoxel, OpDetReadout (if keeping all spacepoints)
        if ((trueTrj.KeyToProcess(couple.second)).find("CoulombScat")!= std::string::npos) continue;
        if ((trueTrj.KeyToProcess(couple.second)).find("LArVoxel")!= std::string::npos) continue;
        if ((trueTrj.KeyToProcess(couple.second)).find("OpDetReadout")!= std::string::npos) continue;
  
        // Let's check if the interaction is in the the TPC
        auto     interactionPos4D =  (truetraj.at(couple.first)).first;
        if ( TPC_BOUND_X[0] > interactionPos4D.X() || interactionPos4D.X() > TPC_BOUND_X[1] ||
             TPC_BOUND_Y[0] > interactionPos4D.Y() || interactionPos4D.Y() > TPC_BOUND_Y[1] ||
             TPC_BOUND_Z[0] > interactionPos4D.Z() || interactionPos4D.Z() > TPC_BOUND_Z[1] ) continue;
  
        // If we made it here, then this is the first interesting interaction in the TPC
        // Store the interaction label and the iterator for the final point
        interactionLabel = trueTrj.KeyToProcess(couple.second);
        lastInTPCpoint = trueTrj.begin() + couple.first; 
        keepInteraction = true;
        nInteractInTPC++;
        break;
      }
    }

    // ### If I didn't find anything interesting in the intereaction map, let's loop back!
    if ( !keepInteraction )
    {
      // Loop on the daughters 
      for (size_t d = 0; d < plist.size(); ++d) 
      {
        auto mcDaught = plist.Particle(d);
        // I'm not interested in CoulombScat
        if (mcDaught->Mother()  != 1 ) continue;
        if ((mcDaught->Process()).find("CoulombScat")!= std::string::npos) continue;

        // Is the daughter born inside the TPC? If yes, store the process which created it 
        simb::MCTrajectory trueDaugthTraj = mcDaught->Trajectory();	     
        TVector3 trjPoint = trueDaugthTraj.begin()->first.Vect(); 

        if ( TPC_BOUND_X[0] > trjPoint.X() || trjPoint.X() > TPC_BOUND_X[1] ||
             TPC_BOUND_Y[0] > trjPoint.Y() || trjPoint.Y() > TPC_BOUND_Y[1] ||
             TPC_BOUND_Z[0] > trjPoint.Z() || trjPoint.Z() > TPC_BOUND_Z[1] ) continue;

        interactionLabel - mcDaught->Process();
        break;
      }	  

      for (auto itTrj = std::prev(trueTrj.end()); itTrj != trueTrj.begin(); itTrj--)
      {
        auto pos = itTrj->first;
        
        if ( TPC_BOUND_X[0] > pos.X() || pos.X() > TPC_BOUND_X[1] ||
             TPC_BOUND_Y[0] > pos.Y() || pos.Y() > TPC_BOUND_Y[1] ||
             pos.Z() > TPC_BOUND_Z[1] ) continue;

        lastInTPCpoint = itTrj;
        break;
      }
    } 

    // ### Exit if the last point is the first point
    if(lastInTPCpoint == firstInTPCpoint) continue;

    // ### Exit if track is too short
    TVector3 firstPos = firstInTPCpoint->first.Vect();
    TVector3 lastPos  = lastInTPCpoint->first.Vect();
    double totalLength = (lastPos-firstPos).Mag();
    if (totalLength < SLAB_SIZE) continue;

    // ### We want to chop up the points between the fist and list uniformely
    // Order them in increasing Z
    std::map<double, TVector3> orderedUniformTrjPts;
    // We want the first and last uniform point to coincide with the 
    // the first and last points we just found 
    orderedUniformTrjPts[firstPos.Z()] = firstPos;
    orderedUniformTrjPts[lastPos.Z()]  = lastPos;

    // ### Calculate the number of points between first and last position
    int nPts = (int) (totalLength/SLAB_SIZE);
    for (int iPtr = 1; iPt <= nPts; iPt++)
    {
      auto newPoint = firstPos + iPt*(SLAB_SIZE/totLength) * (lastPos - firstPos);
      orderedUniformTrjPts[newPoint.Z()] = newPoint;
    }

    // ### Calculate the initial kinetic energy
    auto initialMom =     inTPCPoint->second;
    double initialKE = 1000*(TMath::Sqrt(initialMom.X()*initialMom.X() + initialMom.Y()*initialMom.Y() + initialMom.Z()*initialMom.Z() + mass*mass ) - mass);
    hKEAtTPCFF->Fill(initialKE);
    double kineticEnergy = initialKE;

    // ### Start filling interacting and incident histograms
    auto old_it = orderedUniformTrjPts.begin();
    for (auto it = std::next(orderedUniformTrjPts.begin()); it != orderedUniformTrjPts.end(); it++, old_it++ )
    {
      auto oldPos        = old_it->second;
      auto currentPos    =     it->second;

      double uniformDist =  (currentPos - oldPos).Mag();
      h_UniformDistances->Fill(uniformDist);

      //Calculate the energy deposited in this slice          
      auto old_iter = orderedSimIDE.begin();
      double currentDepEnergy = 0.;
      for ( auto iter= orderedSimIDE.begin(); iter!= orderedSimIDE.end(); iter++,old_iter++)
      {
        auto currentIde = iter->second;
        if (currentIde.z < oldPos.Z()) continue;
        if (currentIde.z > currentPos.Z()) continue;
        currentDepEnergy += currentIde.energy;
      }// Determing which simIDE is within the current slice

      // avoid overfilling super tiny energy depositions
      if (currentDepEnergy/uniformDist < 0.1 ) continue;
      //Calculate the current kinetic energy
      kineticEnergy -= currentDepEnergy;

      hdEVsdX->Fill(currentDepEnergy,(currentPos.Z()-oldPos.Z()) );
      hdEVsKE->Fill(currentDepEnergy,kineticEnergy);
      hIncidentKE->Fill(kineticEnergy);

      h_DEUniform->Fill(currentDepEnergy);
      h_DXUniform->Fill(uniformDist);
      h_DEDXUniform->Fill(currentDepEnergy/uniformDist);
    }//<--- Loop on OrderedPoints
  }//<--- End loop over mc particles
}

void PionXSUsingTruth::beginJob()
{
  // Implementation of optional member function here.
}

void PionXSUsingTruth::beginRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void PionXSUsingTruth::beginSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

void PionXSUsingTruth::endJob()
{
  // Implementation of optional member function here.
}

void PionXSUsingTruth::endRun(art::Run const & r)
{
  // Implementation of optional member function here.
}

void PionXSUsingTruth::endSubRun(art::SubRun const & sr)
{
  // Implementation of optional member function here.
}

DEFINE_ART_MODULE(PionXSUsingTruth)
